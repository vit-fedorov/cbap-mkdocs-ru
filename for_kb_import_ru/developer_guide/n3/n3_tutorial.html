<div class="md-body" data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="comindware" dir="ltr" kb-id="" kb-title="Учебник по N3">
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<nav aria-label="Содержание" class="md-nav md-nav--secondary">
<div class="mce-toc">
<h2 class="toc-heading">
      Содержание
      </h2>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#о-курсе">
<span class="md-ellipsis">
      О курсе
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#типы-синтаксиса-запросов">
<span class="md-ellipsis">
      Типы синтаксиса запросов
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#хранение-данных">
<span class="md-ellipsis">
      Хранение данных
    </span>
</a>
<nav aria-label="Хранение данных" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#пример-триплета">
<span class="md-ellipsis">
      Пример триплета
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#структура-данных-в-comindware-platform">
<span class="md-ellipsis">
      Структура данных в Comindware Platform
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link mkdocs_imported_link" href="#цели-использования-языка-n3">
<span class="md-ellipsis">
      Цели использования языка N3
    </span>
</a>
</li>
</ul>
</div>
</nav>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h2 id="о-курсе">О курсе</h2>
<p>Основная цель курса — научить пользователя ориентироваться в написанных выражениях и самостоятельно писать запросы средней сложности на языке N3. В уроках освещены базовые принципы работы триплетов, интерпретатора, приведены реальные примеры использования. В конце каждого урока представлены задания для самостоятельной работы.</p>
<div class="notice notice-warning">
<p class="admonition-title">Внимание!</p>
<p>Так как это вводный курс, некоторые понятия в нём упрощены, чтобы облегчить понимание работы RDF и Notation 3, без ущерба точности представленной информации.</p>
</div>
<p><strong>Предусловие:</strong> хорошее понимание принципов работы и настройки <strong>Comindware Platform</strong>.</p>
<h2 id="типы-синтаксиса-запросов">Типы синтаксиса запросов</h2>
<p>В <strong>Comindware Platform</strong> предусмотрено два типа синтаксиса запросов:</p>
<ol class="colored_numbers_list">
<li>
<p><strong>Язык формул</strong> — фирменный язык выражений <strong>Comindware</strong>, похожий на Excel. Является простым для восприятия и представляет собой надстройку над <strong>N3</strong>. Для базовой настройки системы его вполне достаточно. Типовые примеры использования языка формул:</p>
<ul>
<li>хождение по связанным шаблонам записи</li>
<li>подсчёт списка объектов</li>
<li>простые математические операции типа умножить, разделить, конкатенация строк т. д.</li>
<li>полный перечень функций языка формул представлен в <a class="mkdocs_imported_link" href="https://kb.comindware.ru/category.php?id=880">справочнике функций</a>.</li>
</ul>
</li>
<li>
<p><strong>Notation 3</strong> (<strong>N3</strong>, <strong>триплеты</strong>) — более сложный в прочтении и написании, но более функциональный и основополагающий язык. Стандарт этого языка определён международным консорциумом W3C.</p>
</li>
</ol>
<h2 id="хранение-данных">Хранение данных</h2>
<p><strong>Comindware Platform</strong> использует графовую базу данных, основанную на модели RDF.</p>
<p>Общая идея графовой модели заключается в том, что любой объект материального и нематериального мира имеет свойства, а эти свойства содержат определённые значения. Следовательно, любую сущность можно описать с помощью простых выражений, которые называют свойства и их значения.</p>
<p>Описание сущности с помощью графовой модели имеет правила. Это происходит в виде так называемого триплета.</p>
<p><strong>Триплет</strong> состоит из трёх связанных сущностей: <strong>Субъект — предикат — объект</strong>.</p>
<p>Эти термины необходимо запомнить, так как они часто используются в курсе.</p>
<h3 id="пример-триплета">Пример триплета</h3>
<p>Триплет можно соотнести с простым предложением вида: <em>Подлежащее — Сказуемое — Дополнение</em>.</p>
<p>Например, утверждение <em>"Книга написана Пушкиным"</em> в RDF-терминологии можно представить следующим образом:</p>
<ul>
<li><strong>субъект</strong> — Книга</li>
<li><strong>предикат</strong> — написана</li>
<li><strong>объект</strong> — Пушкин</li>
</ul>
<p>Теперь построим сам граф. Субъект и объект представлены как узлы. В нашем примере это книга и Пушкин. Свойство, указывающее, кем написана книга, представлено соединительной линией со стрелкой от субъекта к объекту.</p>
<p><img alt="Триплет RDF" src="/platform/v5.0/developer_guide/n3/img/n3_tutorial_triple.png"/></p>
<h3 id="структура-данных-в-comindware-platform">Структура данных в Comindware Platform</h3>
<p>По такому же принципу можно описать структуру данных:</p>
<ul>
<li><strong>Субъект</strong> — запись в шаблоне записи.</li>
<li><strong>Предикат</strong> — атрибут записи.</li>
<li><strong>Объект</strong> — значение атрибута.</li>
</ul>
<p>Например, имеется шаблон записи «Книги». В шаблоне имеются атрибуты «Наименование» и «Автор». В шаблоне имеются две записи.</p>
<p>Данные этих записей хранятся в триплетах и в упрощённом виде выглядят примерно так:</p>
<p><code>id 8037 – Название – «Война и мир».</code>
<code>id 8037 – Автор – «Толстой».</code>
<code>id 8036 – Название – «Медный всадник».</code>
<code>id 8036 – Автор – «Пушкин».</code></p>
<p><img alt="Пример записей в шаблоне «Книги»" src="/platform/v5.0/developer_guide/n3/img/n3_tutorial_registry.png"/></p>
<p>Аналогичным образом хранится вся метаинформация (описания шаблонов записи, форм, объектов, типов и т. д.), а также атрибуты окружения (текущий пользователь, текущее время, текущий контекст и т. д.).</p>
<p>Такая структура обеспечивает единообразие и простоту доступа к данным через запросы к базе.</p>
<p>Явные преимущества использования триплетов для описания и хранения данных:</p>
<ol class="colored_numbers_list">
<li><strong>Простота понимания модели данных.</strong> Создание шаблонов записи и связей между ними быстро усваивается даже неподготовленным пользователем.</li>
<li><strong>Мгновенное добавление новых шаблонов записи и атрибутов,</strong> которые сразу доступны к работе.</li>
<li><strong>Неограниченная ширина и глубина связей между сущностями.</strong> В <strong>Comindware Platform</strong> нет ограничений по количеству атрибутов и связей между ними.</li>
<li><strong>Простота и неограниченность навигации по связям.</strong> Переход из одного справочника в другой через ссылочное поле осуществляется единообразно.</li>
</ol>
<p>Для лучшего понимания принципов описания и хранения данных без использования жёсткой структуры (такой, как таблицы в SQL), ознакомьтесь со статьёй <em><a class="mkdocs_imported_link" href="https://kb.comindware.ru/article.php?id=4856">«Онтология»</a></em>.</p>
<div class="notice notice-success">
<p class="admonition-title">Внутренняя логика работы Comindware Platform</p>
<p>К примеру, при создании вычисляемого атрибута используется формула.</p>
<p>Что происходит под «капотом» после написания формулы? Компилятор переводит её в запрос N3, который уже однозначно понятен системе.</p>
<p>Можно сделать вывод: если есть желание облегчить работу компилятора, пишите формулу сразу на N3.</p>
</div>
<h2 id="цели-использования-языка-n3">Цели использования языка N3</h2>
<ul>
<li><strong>Продвинутое использование Comindware Platform.</strong></li>
<li><strong>Доступ ко всем созданным и системным атрибутам.</strong> В интерфейсе <strong>Comindware Platform</strong> представлены не все системные атрибуты, а только те, которые используются чаще всего в типовых сценариях. N3 предоставляет доступ ко большему количеству атрибутов и сущностей, чем формулы.</li>
<li><strong>Расширенные возможности работы с данными.</strong> Дополнительные математические функции, функции для работы со списками, приведения данных к одному типу, расчётов времени и т.д. См. <em><a class="mkdocs_imported_link" href="https://kb.comindware.ru/category.php?id=877">руководство по написанию выражений на N3</a></em>.</li>
</ul>
<h1 id="1-урок">1 урок</h1>
<h2 id="чему-научимся">Чему научимся</h2>
<ul>
<li>Триплеты, синтаксис, переменные, параметры <code>?item</code> и <code>?value</code>.</li>
</ul>
<h2 id="триплеты">Триплеты</h2>
<p>Тело запроса состоит из триплетов вида <code>субъект – предикат – объект</code>, которые мы рассмотрели во введении.</p>
<p><strong>Пример запроса:</strong></p>
<div class="highlight"><code><pre><span></span><code><span class="p">{</span></code> <br/><code>    <span class="err">?item</span> <span class="err">?company</span> <span class="err">?customer</span><span class="p">.</span></code> <br/><code>    <span class="err">?customer</span> <span class="err">?timeResolveProperty</span> <span class="err">?timeResolve</span><span class="p">.</span></code> <br/><code>    <span class="err">?timeResolve</span> <span class="err">?requestTypeProperty</span> <span class="err">?value</span><span class="p">.</span></code> <br/><code><span class="p">}</span></code> <br/></pre></code></div>
<p>С помощью такого запроса мы указываем, какая строка из БД необходима, чтобы получить требуемые данные из графа.</p>
<p>Например, в контексте записи заявки:</p>
<ul>
<li>Первым триплетом находим ссылку на клиента.</li>
<li>Вторым триплетом определяем время ответа на заявку.</li>
<li>Третьим триплетом указываем тип времени ответа.</li>
</ul>
<p>В синтаксисе языка RDF N3 существуют определённые правила, без соблюдения которых запрос не будет сохранён и выполнен корректно.</p>
<p>Вот основные основные правила:</p>
<ol class="colored_numbers_list">
<li>Каждый триплет начинается с новой строки.</li>
<li>Объявление переменных производится с префиксом <code>?</code> (например, <code>?variable</code>).</li>
<li>Весь запрос помещается в фигурные скобки (<code>{}</code>).</li>
<li>В конце каждого триплета ставится точка (<code>.</code>).</li>
<li>Интерпретатор учитывает регистр символов, то есть <code>?variable</code> и <code>?Variable</code> — это две разных переменных.</li>
</ol>
<h2 id="переменные">Переменные</h2>
<p>При формировании запроса используются переменные.</p>
<p><a class="mkdocs_imported_link" href="https://ru.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F_%28программирование%29">Переменная</a> — это именованное хранилище данных, обозначаемое в N3 символом <code>?</code>.</p>
<p>В приведённом примере используются переменные <code>?customer</code> и <code>?timeResolve</code>, которые содержат ссылки на шаблоны записи.</p>
<p>Имена переменных следует задавать так, чтобы отражать суть хранимых данных.</p>
<div class="notice notice-info">
<p class="admonition-title">Примечание</p>
<p>В данном примере переменными являются все объекты из триплета после символа «?». Это сделано для наглядности.</p>
<p>В следующих уроках мы научимся определять предикат через переменную.</p>
</div>
<h2 id="входные-и-выходные-параметры-item-и-value">Входные и выходные параметры <code>?item</code> и <code>?value</code></h2>
<p>Наш пример начинается и заканчивается использованием двух переменных: <code>?item</code> и <code>?value</code>. Это особые зарезервированные системные переменные:</p>
<ul>
<li><code>?item</code> — входной параметр запроса. Его значение определяется контекстом, в котором выполняется запрос. Например, при вычислении значения атрибута <code>?item</code> содержит ID текущей записи. Подробные сведения см. в <a class="mkdocs_imported_link" href="https://kb.comindware.ru/category.php?id=877">Руководстве по написанию выражений на языке N3</a>/</li>
<li><code>?value</code> — выходной параметр. В него помещается результат запроса. Обратите внимание: тип данных, помещённых в <code>?value</code>, должен совпадать с типом данных атрибута, в который записывается результат, например, логическому или числовому.</li>
</ul>
<p><strong>Итого:</strong> мы разобрались с телом запроса, основными правилами синтаксиса,</p>
<h2 id="задачи">Задачи</h2>
<p>Модель данных: у нас имеется шаблоны записи «Договоры», «Контрагенты» и «Статусы контрагента». У договора есть ссылка на контрагента, а у контрагента есть ссылочное поле на статус.</p>
<p>Мы находимся в контексте договоров. Нам нужно вывести статус контрагента.</p>
<p>Предикаты:</p>
<p>?agentProperty - предикат контрагента</p>
<p>?statusProperty - предикат ссылки на статус у контрагента</p>
<p>Требуется написать запрос и получить значение статуса контрагента.</p>
<p>Разберем общую модель написания запроса на N3.</p>
<p>В общем виде запрос состоит из:</p>
<ol class="colored_numbers_list">
<li>Подключаемые библиотеки пространств имен</li>
<li>Использование переменных.</li>
<li>Триплеты</li>
</ol>
<h2 id="итого">Итого</h2>
<p>В итоге, мы научились использовать библиотеку object и ее функцию по записи URI предикатов в переменную.</p>
<p>Познакомились со структурой триплетов.</p>
<p>Разобрали входные и выходные параметры запроса (Item и value)</p>
<p>Познакомились с основными правилами синтаксиса запроса.</p>
<h2 id="задачи_1">Задачи</h2>
<p>Создаем модель данных:</p>
<p>Три шаблона записи. Первый шаблон имеет числовой атрибут «Calculation» и атрибут ссылку на второй шаблон. Второй ШЗ имеет ссылку на третий. В третьем ШЗ создаем атрибут «Number». У шаблонов создаем по одной записи и устанавливаем ссылочные поля. В атрибут «Number» пишем число.</p>
<p>Задача: вычислить в атрибут Calculation значение атрибута Number.</p>
<h1 id="2-урок">2 урок</h1>
<h2 id="чему-научимся_1">Чему научимся</h2>
<p>Библиотеки пространств имен, присвоение переменных, применение системных атрибутов, built-in предикаты, конструкция from.</p>
<p>Итак, начнем разбор первого полноценного запроса.  Для  ее анализа нужно знать модель данных, в которой мы его пишем.</p>
<p>Пример:</p>
<p>Напишем запрос, который пройдет по ссылке в IssueType, возьмет значение текстового атрибута Title и выведет его.</p>
<p><strong>Модель данных:</strong></p>
<p>Два шаблона записи – Issue и Type.</p>
<p>В ШЗ Issue имеется ссылка на ШЗ Type. Имя: «IssueType».</p>
<p>В ШЗ Issue есть текстовый атрибут TitleCalc. В нем пишем текущий запрос.</p>
<p>В ШЗ Type создан текстовой атрибут Title.</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.005.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>В обычном Expression Language выглядел бы так:</p>
<p>$IssueTypeRef-&gt;Title</p>
<p>Пример в Expression language приведен лишь для введения в понимание. В дальнейшем, не следует пытаться представлять выражение N3 в Expression Language, так как это может сбить с верного понимания.</p>
<p>Начнем разбор построчно:</p>
<p>Первую строку, которую мы видим - это библиотека «пространства имен».  </p>
<div class="highlight"><code><pre><span></span><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">object:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/ontology/object#&gt;</span><span class="p">.</span></code> <br/></pre></code></div>
<h2 id="библиотеки-пространств-имён">Библиотеки пространств имён</h2>
<p><strong>Библиотеки</strong> - это подключаемые модули (области), где лежат знания об объектах, функциях и разных правилах. С их помощью мы можем обращаться с системным и прикладным атрибутам и брать их значения. Также, при объявлении библиотек может появляться доступ к различным функциям по работе с датами, списками, числами и т.д. (<a class="mkdocs_imported_link" href="https://kb.comindware.com/article.php?id=1482">ссылка на документ</a>).</p>
<p>С помощью этой библиотеки у нас появляется доступ к функции object:findProperty из строки 3 и 4 нашего примера. Данная функция позволяет брать URI атрибутов, записывать в переменные и использовать их внутри запроса.</p>
<p>Так как модель описания данных – RDF, для нее определены некоторые стандарты. Так, один из стандартов - это хранение в виде URI.</p>
<p>URI — последовательность символов, идентифицирующая абстрактный или физический ресурс и выглядит он примерным образом:</p>
<div class="highlight"><code><pre><span></span><code>https://www.w3.org/1999/02/22-rdf-syntax-ns#type</code> <br/></pre></code></div>
<p>По сути каждая сущность из триплета является либо URI, либо литералом. При использовании полной нотации RDF выражений, происходит появление в записи длинных строк вида:</p>
<p><em><a class="mkdocs_imported_link" href="img/n3_tutorial_rdf_triple.png">RDF-триплет</a></em></p>
<p>Эта библиотека и функция является одной из базовых и в дальнейшем будет часто использоваться в написании запросов. Она содержит в себе функцию поиска id атрибута по его системному имени.</p>
<p>Перейдем к строке 3 и 4.</p>
<p>В предыдущем уроке мы не касались темы предикатов в триплете. Они были даны изначально. Но по сути каждая часть из триплета лежит в переменных, в том числе и искомые атрибуты. Чтобы их определить и записать в переменную пишем выражение вида:</p>
<div class="highlight"><code><pre><span></span><code><span class="p">(</span><span class="s">"Сист.ИмяШЗ"</span> <span class="s">"Сист.ИмяАтрибута"</span><span class="p">)</span> <span class="nn">object</span><span class="p">:</span><span class="nt">findProperty</span> <span class="err">?переменная</span><span class="p">.</span></code> <br/></pre></code></div>
<p>Эта функция подходит только для определения прикладных атрибутов (созданных вручную). Системные атрибуты лежат в других библиотеках.</p>
<p>Теперь, вместо длинных URI предикатов, мы можем использовать переменные.</p>
<p>Берем атрибуты нужных предикатов для запроса и присваиваем их в переменные IssueTypeProperty и titleProperty.</p>
<p>Где, имя переменной определяем сами.</p>
<h2 id="триплет">Триплет</h2>
<p>С первыми тремя строчками разобрались. Начинаем писать сам триплет.</p>
<figure class="screenshot_with_caption">
<p><img alt="Компоненты триплета" src="/platform/v5.0/developer_guide/n3/img/n3_tutorial_triple_parts_numbered.png"/><figcaption class="caption">Компоненты триплета</figcaption></p>
</figure>
<ol class="colored_numbers_list">
<li>
<p>Каждый запрос имеет входной параметр <code>?item</code>. Он вычисляется по умолчанию и служит для определения текущей записи, в которой находится атрибут.</p>
</li>
<li>
<p>Указываем предикат. Мы его уже определили выше.</p>
</li>
<li>
<p>Создаем переменную, в которую поместится значение. Имя этой переменной придумываем сами. Интерпретатор видит, какой части не хватает для триплета и автоматически присваивает в него некое значение.</p>
</li>
</ol>
<p>Данной строкой мы добились того, что смогли определить ссылку, чье значение требуется для дальнейшего нахождения поля <code>title</code>.</p>
<p>Важное правило работы интерпретатора:</p>
<p>Если результат триплета будет false - а именно он не найдет такого предиката, либо вместо объекта мы впишем уже определенное значение и интерпретатор не найдет такую строчку в базе, тогда он останавливается и вниз дальше не идет.</p>
<p>Разбираем 7 строку.</p>
<div class="highlight"><code><pre><span></span><code><span class="err">?IssueType</span> <span class="err">?TitleProperty</span> <span class="err">?value</span><span class="p">.</span></code> <br/></pre></code></div>
<p>Берем переменную, которую определили выше. Так как, мы переместились по ссылке и находимся в контексте ШЗ <code>IssueType</code>, у него имеется предикат <code>TitleProperty</code>. Указываем его.</p>
<p>И третьим аргументом идет обязательная переменная value. value - является выходным параметром запроса. То что мы поместим в нее, то и будет отображаться в вычисляемом атрибуте. Тип данных, помещенный в value должно быть согласован с типом атрибута. Например: если вычисления в атрибуте логического типа, в value нужно получить логическое значение. И такое же правило существует для остальных типов данных.</p>
<h2 id="присвоение-переменных">Присвоение переменных</h2>
<p>В предыдущем примере мы использовали ситуацию, где в триплетах субъект и предикат были определены. Неизвестным являлся объект.</p>
<p>Интерпретатор понимает какая сущность из триплета неизвестна и тут же присваивает в нее недостающее значение.</p>
<p>Но это не единственный возможный случай присваивания. Всего существует три основных варианта присвоения значений в переменные с помощью работы триплета.</p>
<ol class="colored_numbers_list">
<li>
<p>Первый способ, используемый в примере 1 урока.  Субъект и предикат определен, значит искомое значение - это объект.</p>
<p><figure class="screenshot_with_caption" markdown=""><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.008.png"/><figcaption class="caption"></figcaption></figure></p>
</li>
<li>
<p>Триплет позволяет идти и от обратного, если известен объект и предикат, то мы находим субъект</p>
<p><figure class="screenshot_with_caption" markdown=""><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.009.png"/><figcaption class="caption"></figcaption></figure></p>
</li>
<li>
<p>Это так называемый ExactMatch. В случае, где известны все три части, происходит проверка на полное совпадение. Здесь получаем уточненное значение субъекта.</p>
</li>
</ol>
<figure class="screenshot_with_caption" markdown="block">![](img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.010.png)&lt;figcaption&gt;&lt;/figcaption&gt;</figure>
<p>Рассмотрим еще один пример с новым типом присвоения значения переменным:</p>
<p>Задача: в некоторых случаях администратор приложения хочет быстро и наглядно увидеть есть ли среди заявок те, у которых в запущенном процессе имеется ошибка.</p>
<p>Суть вычисления - если у текущей записи имеется процесс с ошибкой, вывести true в логический атрибут.</p>
<p>Модель данных:</p>
<p>У нас имеется процесс и связанный шаблон записи. В связанном шаблоне записи создаем логический вычисляемый атрибут. В вычислениях пишем:</p>
<div class="highlight"><code><pre><span></span><code><span class="k">@prefix</span><span class="w"> </span><span class="nn">process:</span><span class="w"> </span><span class="nv">&lt;http://comindware.com/ontology/process#&gt;</span><span class="p">.</span></code> <br/><code><span class="p">{</span></code> <br/><code>    <span class="err">?proc</span> <span class="nn">process</span><span class="p">:</span><span class="nt">businessObject</span> <span class="err">?item</span><span class="p">.</span></code> <br/><code>    <span class="err">?proc</span> <span class="nn">process</span><span class="p">:</span><span class="nt">hasTokenError</span> <span class="err">?value</span><span class="p">.</span></code> <br/><code><span class="p">}</span></code> <br/></pre></code></div>
<p>Начнем разбор построчно:</p>
<p>1 строка - подключаем библиотеку пространств имен процесса. После данного подключения становятся доступны системные предикаты процесса.</p>
<h2 id="системные-атрибуты">Системные атрибуты</h2>
<p>В платформе предусмотрено два вида атрибутов: системные и прикладные. К прикладным мы относим, те сущности, которые были вручную созданы для нашей онтологии.</p>
<p>Но также, у каждого объекта в платформе (Процессы, шаблоны записи, группы, глобальные настройки и т.д.) есть ряд системных атрибутов, которые не всегда видны в интерфейсе программы, но они существуют и как правило логика наполнения данными таких атрибутов уже предопределена и автоматически заполняется системой.</p>
<p>3 строка - тут мы имеем ситуацию с переменными, когда неизвестен один субъект (2 случай).  Мы знаем что у процесса есть предикат businessObject, который связывает запись с процессом. +Этот атрибут является системным.  Поэтому, первым пишем переменную, затем ее предикат и объект. По итогу в переменной «proc» у нас появился текущий, связанный с записью, процесс.</p>
<p>4 строка - здесь имеем уже первый вид присваивания. Предикат в этой строке тоже системный. Он является логическим типом и его значение становиться true, если запущенный процесс имеет ошибку. Соответственно его значение мы и передаем в выходной параметр value.</p>
<p>Так мы выведем в атрибут екгу, если есть ошибка в процессе.</p>
<h2 id="встроенные-предикаты">Встроенные предикаты</h2>
<p>Помимо, обычных предикатов, которые описывают свойства сущностей в платформе мы имеем также Встроенные предикаты. Это сложные предикаты, которые носят в себе какие-либо функции по работе со строками, датами и т.д. Список таких предикатов описан в документе основы N3.</p>
<p>Рассмотрим пример:</p>
<p>Задача: У нас есть ШЗ TemplateOne. У ШЗ есть коллекция.  У коллекции имеется числовой атрибут. Требуется вывести сумму записей коллекции этого числового поля в вычисляемый числовой атрибут ШЗ.</p>
<p>Пример:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.012.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>2 строка - добавляем библиотеку, содержащую в себе ряд математических функций.</p>
<h2 id="конструкция-from-">Конструкция <code>from {}</code></h2>
<p>7 строка - добавляем конструкцию <code>from {}</code>. Так как мы используем математическую функцию суммирования, ей требуется получить на вход такой тип данных, как «list». Если бы мы просто нашли переменную collnumbers и попытались бы ее применить к функции без преобразования в list, тогда бы ничего не вышло. В collnumbers хранятся uri к значениям записей, а данная функция не работает с uri. Ей нужен понятный для нее тип данных. Какой тип данных требуется на вход разным функциям описано в документе N3.</p>
<p>Структура конструкции: <code>from {триплеты} select ?переменная -&gt; ?лист.</code></p>
<p>11 строка - пишем наш built-in предикат «cmwmath:sum». В переменную value запишется получившаяся сумма из списка чисел numbersList.</p>
<h2 id="итого_1">Итого</h2>
<p>Теперь мы умеем применять разные типы присвоения значений в переменные, используем системные атрибуты в наших запросах, производим вычисления с помощью встроенных предикатов.</p>
<p>Задачи:</p>
<h1 id="3-урок">3 урок</h1>
<h2 id="чему-научимся_2">Чему научимся</h2>
<p>Итератор,  Assert, if, or, контейнеры.</p>
<p>В данном уроке мы будем знакомиться с работой итератора, от которого зависит быстродействие выполнения запроса. Также, познакомимся с отдельными частоиспользуемыми функциями.</p>
<h2 id="итератор">Итератор</h2>
<p>Еще одна важная особенность при работе с с запросами —  это итератор.</p>
<p>Итератор — это перечислитель, который поддерживает простой перебор по группе ссылок. К группе ссылок относятся коллекции и ссылки со множественными значениями в них.</p>
<p>Под перебором мы имеем в виду,  что итератор в порядке случайной очереди берет первый объект из коллекции и проверяет его на верность выполнения условий по всем нижестоящим триплетам.  Пример:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.013.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>В переменную coll мы получили коллекцию.  Енумератор взял первую запись из коллекции и пошел на 10 строчку. В этой строке мы делаем ExactMatch (3 тип присваивания). Мы проверяем что у этой записи в атрибуте Number значение 15.</p>
<p>Если у этой записи значение не 15, тогда результат триплета равен false, и эта запись выбрасывается из результата и мы возвращаемся обратно на 9 строку и берем следующую запись коллекции.</p>
<p>Если результат следующей записи true, тогда запись двинулась дальше на 11 строку и так до конца тела запроса. Таким образом, он повторяет свои действия пока не закончатся уникальные записи.</p>
<p>Важное примечание: итератор работает всегда. Он пытается вернуться и к верхней строчке и проверить есть ли значения, который он не проверял. Возвращается наверх, сверяет значение с записанным хэшем. Если это значение уже было, он останавливается.</p>
<p>Из этого следует правило, что вверху запроса следует указывать</p>
<p>В случае, если мы точно знаем, что итератор должен пройти один раз по телу запроса (нету ссылок со множественным значением или коллекций), тогда внутри тела, триплеты можно обернуть в конструкцию once {}. Она сделает запрос быстрее.</p>
<h2 id="логическое-и">Логическое И</h2>
<p>Распространены ситуации, где нужно объединить два условия выборки «логическим и». В N3 нам не нужны специальные функции, так как между строками триплетов по умолчанию используется конъюнкция.</p>
<p>Предположим, что мы пишем какое то условие применения в правила на форме. Мы должны получить значение truе, если атрибуты PlannedStartDate и PlannedEndDate пустые.</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.014.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>6 строка — проверяем чтобы атрибут PlannedStartDate был пуст.</p>
<p>Проверка на пустоту происходит подобным синтаксисом:</p>
<div class="highlight"><code><pre><span></span><code><span class="err">not</span> <span class="p">{</span><span class="err">?субъект</span> <span class="err">?предикат</span> <span class="err">?</span><span class="p">.}</span></code> <br/></pre></code></div>
<p>Знак-точка вместо объекта означает, что в нем есть данные. Соответственно, мы добавляем not и у нас получается проверка на пустоту.</p>
<p>Предположим, что 6 строка выдала true(атрибут пустой) , тогда интерпретатор перешел 7 строке.</p>
<p>Если в 7 строке интерпертатор выдаст false, то он заканчивает работу и не запишет в value значение true.</p>
<p>Таким образом, ему требуется, чтобы в 6 и 7 выполнились условия.</p>
<h2 id="логическое-или">Логическое ИЛИ</h2>
<p>Если же мы хотим изменить наше условие, и хотим выводить true, если хоть один атрибутов пуст, тогда условие будет следующее:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.015.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>Такое правило уже является «логическим или». Синтаксис условия or:</p>
<p>or {триплеты}</p>
<p>or{триплеты}.</p>
<p>Прим — в конце перечислений or обязательно должна стоять точка.</p>
<p>or-ов может быть несколько.</p>
<h2 id="условный-оператор-if">Условный оператор IF</h2>
<p>If -- условный оператор позволяет проверить некоторое условие и в зависимости от результатов проверки выполнить то или иное действие.</p>
<p>Пример:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.016.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>Синтаксис: if {условие}</p>
<p>then {выполняется, если условие - true}</p>
<p>else {выполняется, если условие - false}</p>
<h2 id="assertunion">Assert:union</h2>
<p>Еще одна часто используемая функция для работы с запросами — это вызов assert: union true.</p>
<p>Данная функция требуется, когда в запросе нужно объединить несколько результатов выполнения в одну переменную.</p>
<p>Пример:</p>
<p>Предположим, в заявке имеется поле с выбором Руководителя (User1) и заместителя руководителя (User2). Нам требуется объединить эти два значения в вычисляемом атрибуте:</p>
<figure class="screenshot_with_caption">
<p><img alt="" src="/platform/v5.0/developer_guide/n3/img/Aspose.Words.3a78cd59-6370-458f-9e8c-c43e0d91fc2a.017.png"/><figcaption class="caption"></figcaption></p>
</figure>
<p>В строке 8 и 9 мы использовали одноименную переменную для того, чтобы и в нее записалось объединенное значение.</p>
<p>Синтаксис функции:</p>
<div class="highlight"><code><pre><span></span><code><span class="p">(</span></code> <br/><code></code> <br/><code><span class="p">{</span><span class="err">триплет</span><span class="p">}</span></code> <br/><code></code> <br/><code><span class="p">{</span><span class="err">триплет</span><span class="p">}</span></code> <br/><code></code> <br/><code><span class="p">)</span> <span class="nn">assert</span><span class="p">:</span><span class="nt">union</span> <span class="l">true</span><span class="p">.</span></code> <br/></pre></code></div>
<h2 id="итого_2">Итого</h2>
<p>Мы разобрались в работе Итератора. Умеем применять логические условия для фильтров и так же объединять результаты запросов в одну переменную.</p>
<p>Данные функции являются самыми часто используемыми в запросах.</p>
</article>
</div>
</div>
<a class="md-top md-icon mkdocs_imported_link" data-md-component="top" href="#">
<i class="fa-light fa-arrow-up">&zwnj;<!--icon--></i>
            К началу
          </a>
</main>
</div>
<script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": true, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></div>